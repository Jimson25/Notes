# 泛型

## 什么是泛型？为什么要使用泛型？

泛型是一种参数化类型的机制，允许我们编写通用的代码，可以在运行时指定具体的类型。使用泛型可以提高代码的可读性、安全性和重用性。

## 什么是泛型类和泛型方法？

- 泛型类 ：一个类可以使用泛型来定义其属性、方法或构造函数的参数类型。例如，`ArrayList<T>` 是一个泛型类，其中的 `T` 表示元素的类型。

* **泛型方法** ：一个方法可以使用泛型来定义其参数类型或返回值类型。例如，`public <T> T getFirst(List<T> list)` 是一个泛型方法，它返回列表中的第一个元素

## 什么是类型擦除？

类型擦除是指在编译时擦除泛型类型信息，将泛型类型转换为原始类型。

1. **类型擦除** ：

* Java的泛型在编译期间会将所有的泛型信息擦除，替换为实际的类型。
* 在生成的字节码中，不包含泛型中的类型信息。
* 使用泛型时，编译器会在编译时去掉类型参数，这个过程称为类型擦除。
* 例如，定义 `List<Object>`和 `List<String>`等类型，在编译后都会变成 `List`，JVM看到的只是 `List`，而泛型附加的类型信息对JVM是不可见的。

1. **类型擦除后保留的原始类型** ：

* 原始类型是擦除泛型信息后，类型变量的真正类型。
* 无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用 `Object`）替换。
* 例如，`Pair<T>`中，如果 `T`是无限定的类型变量，那么用 `Object`替换，结果就是一个普通的类，类似于泛型加入Java语言之前的已经实现的样子。

1. **示例** ：

* 假设我们有一个泛型类 `Pair<T>`，如果 `T`是无限定的类型变量，那么原始类型就是 `Object`。
* 如果类型变量有限定，原始类型就用第一个边界的类型变量类替换。

**深入一些去了解：**

我们已经知道，在编译期间，编译器会执行类型擦除，`ArrayList<Integer>`变为了原始类型 `ArrayList`，并且它的元素类型被视为 `Object` 。但是这里需要注意一点，这里擦除的只是编码时传入的静态的元素类型，如这里的Integer，在实际运行过程中，传入的元素的实际类型是会被保留的。比如这里，在内存中呈现的依然是元素真实的类型Integer。

可以简单点理解，将泛型理解为一种开发期间编译器对开发人员的一种约束，它为开发人员在开发期间提供一种强类型检查机制，开发人员可以在编译期间检查到类型错误，而不必等待运行时才发现。

如下面的代码，结果返回为 `true` ，因为在实际内存中，元素的类型还是Integer。

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(1);
System.out.println(list.get(0) instanceof Integer);
```

## 什么是伪泛型？为什么java中的泛型是伪泛型？

伪泛型是指 Java 中的泛型机制在编译期间会将所有的泛型信息擦除，替换为实际的类型。尽管我们在源代码中使用了泛型，但在生成的字节码中，不包含泛型类型信息。因此，我们称之为“伪泛型”。

具体来说，以下是关于伪泛型的一些要点：

* **类型擦除** ：在编译期间，Java 编译器会将泛型信息擦除，将泛型类型转换为原始类型。这意味着在运行时，我们无法直接查看泛型的具体类型。
* **原始类型** ：原始类型是擦除泛型信息后，类型变量的真正类型。无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用 `Object`）替换。

虽然泛型在源代码中提供了类型安全性和抽象性，但在运行时，泛型的类型信息被擦除，只保留了原始类型。因此，我们称之为“伪泛型”。

Java 中的泛型是伪泛型，因为在运行时并没有实际的泛型类型信息，只有在编译时才会进行类型检查。

## 什么是泛型的上下界通配符？起到什么作用？

* **上界通配符** （`<? extends T>`）：表示泛型参数必须是 `T` 或其子类。
* **下界通配符** （`<? super T>`）：表示泛型参数必须是 `T` 或其父类。
