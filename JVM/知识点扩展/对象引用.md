# 对象间的引用关系

## 概述
1. 在JDK1.2中，java对引用的概念进行了扩充，将对象间的引用分为`强引用(Strong Reference)`、`软引用(Soft Reference)`、`弱引用(Weak Reference)`、`虚引用(Phantom Reference)`四种，这四种引用强度`依次递减`。
    - `强引用`： 最常用的引用定义，指的是对象间的赋值关系(Object obj = new Object();)。无论是在那种情况下，只要强引用关系存在，jvm就不会回收掉被引用的对象。

    - `软引用`：在系统将要发生内存溢出之前，会把这些对象列入到回收范围进行二次回收。如果回收之后还是没有足够的内存，才会抛出OOM。

    - `弱引用`：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。

    - `虚引用`：一个对象是否有虚引用存在，完全不会对其生存时间产生影响，也无法通过虚引用获取一个对象的实例。为对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 一、强引用
1.  在普通的java系统中，99%的引用关系都是强引用。只要强引用的对象是可触及的，那么垃圾收集器就永远不会回收被引用的对象。

2. 只有当一个对象的引用关系被置位null或程序运行出了对象的作用域，强引用对象才会被回收。


## 二、软引用

1. 软引用用来描述一些还有用但是不是必须的对象。`只被软引用关联的对象，在系统将要发生内存溢出时，会把这些对象列入回收范围进行二次回收，如果回收后还没有足够的内存空间才会抛出OOM。`

2. 软引用通常用来实现内存敏感的缓存，如高速缓存等。如果内存空间足够，就可以暂时保留缓存，当内存空间不足的时候就清理掉。这样就可以在保证实现缓存的同时保证了内存不会被耗尽。

3. 软引用实现
     ```java
    public class Test3 {
        public static void main(String[] args) {
            //通过匿名对象的方式创建一个对象并给这个对象创建一个软引用
            SoftReference<Object> reference = new SoftReference<>(new Object());
            //通过软引用获取到对象实例
            Object obj = reference.get();
            obj.toString();
        }
    }
    ```

## 三、弱引用

1. 弱引用也是用来描述那些非必须的对象，`只被弱引用关联的对象只能生存到下一次垃圾回收。`在系统进行垃圾收集的时候，弱引用对象一定会被当做垃圾被回收掉。

2. 由于垃圾收集器的线程优先级通常都比较低，因此并不一定能很快的发现持有弱引用的对象，所以弱引用的对象可以存在较长的时间。

3. `软引用和弱引用都比较适合用来做系统缓存`。这样的实现方式可以在系统内存不够的时候将其作为垃圾进行回收，而当系统内存充足的时候这些对象又可以起到加速的作用。

4. 代码实现
    ```java
    public class Test5 {
        public static void main(String[] args) {
            //通过匿名对象的方式创建一个对象并使用这个对象创建一个弱引用
            WeakReference<Object> weakReference = new WeakReference<>(new Object());
            //通过弱引用对象获取到对象的真实对象（强引用）并打印其内存地址
            System.out.println(weakReference.get().toString());
        }
    }
    ```

## 四、虚引用

1. 虚引用也被称为幽灵引用，是所有引用类型中引用关系最弱的一个。一个对象是否有虚引用存在完全不会影响其生命周期。如果一个对象仅持有虚引用，那么它就和没有引用一样随时都可能被回收。

2. 为一个对象设置虚引用关联的唯一目的是用于跟踪垃圾收集过程。如能在这个对象被收集器回收的时候收到一个系统通知。

3.  虚引用必须和引用队列一起使用。虚引用在创建的时候必须为其提供一个引用队列作为参数。当垃圾收集器准备回收一个对象时，如果发现他还有一个虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。

4. 由于虚引用可以跟踪对象的回收时间，因此，可以将一些资源释放操作放在虚引用中执行和记录。
    ```java
    public class Test6 {
        public static void main(String[] args) throws InterruptedException {
            ReferenceQueue<Inner> queue = new ReferenceQueue<>();
            PhantomReference<Inner> phantomReference = new PhantomReference<>(new Inner(), queue);
        }
    }

    class Inner{
        @Override
        public String toString() {
            return "Inner{}";
        }
    }
    ```

  

