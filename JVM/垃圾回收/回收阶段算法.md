## 垃圾收集回收阶段算法

### 一、标记-清除算法

1. 背景
    - 标记清除算法是一种简单基础的算法，该算法与1960年提出并被引用于Lisp语言。

2. 执行过程
    - 当堆中的内存空间被消耗完后，会停止应用程序并执行两项操作，分别为标记和清除。
    - `标记: `从根节点开始遍历堆空间，标记`所有被引用的对象`，一般是在对象的Header中记录为可达的对象（可达性分析）
    - `清除：`垃圾收集器从头到尾对堆空间进行线性遍历，如果发现某个对象的Header中没有标记为可达的对象，就将其当做垃圾进行回收。

3. 缺点：
    - 执行效率低，需要对堆空间进行两次遍历
    - 进行GC时需要停止整个应用程序，用户体验较差
    - 清理后的内存空间是不连续的，会产生大量的内存碎片，需要维护一个空闲列表。

4. 注意：
    - 这里的清除并不是将内存置空，而是将需要回收的内存地址保存到空闲列表中，在下次进行对象分配时，只需要在空闲列表查找大小合适的空间进行对象分配即可。

### 二、复制算法

1. 核心思想：
    - 将内存空间分为两块，每次只使用一块，在垃圾收集时将正在使用的内存中存活的对象复制到未被使用的内存区域中，之后清除正在使用的内存区域中的所有对象，再交换两个内存的角色完成垃圾收集。

2. 优点：
    - 没有清除过程，实现简单，运行高效。
    - 复制后内存空间连续，不会出现内存碎片。

3. 缺点：
    - 占用内存空间较多
    - 对于G1这种拆分成大量Region的GC，复制而不是移动意味着GC需要维护region之间的对象引用关系，内存占用或者实现开销都比较大。

4. 注意：
    - 由于复制算法需要移动存货对象，所以比较适合对对象生命周期较短的内存区域进行垃圾收集。
    - 在常规应用中，大多数对象的生命周期都是朝生夕死的，这一点和复制算法的需求比较契合。目前大多数商业虚拟机都是使用复制算法来回收新生代。

### 三、标记-整理(压缩)算法

1. 背景：
    - 在新生代中，一般对象的生命周期都是朝生夕死，使用复制算法进行垃圾收集能有效提高程序运行效率。但是在老年代中，对象的生命周期都是比较长的，如果此时还使用复制算法，那么久会拖慢程序执行效率。而标记-清除算法执行效率并不高并且在执行完之后还会产生大量的内存碎片，所以开发人员在其基础上设计了标记-整理算法。

2. 执行过程：
    - 标记阶段：该阶段和标记清除算法一样都是对内存中存活的对象进行标记并在对象的Header中进行记录。
    - 整理阶段：该阶段会遍历整个内存区域并将存活的对象按顺序整理到内存中的一端，在此阶段后内存中的空闲空间是一块连续的内存空间，不会产生碎片问题。

3. 注意：
    - 标记-整理算法执行效果等同于执行完标记-清除算法后再对内存中的对象进行一次整理，因此也可以将它称为`标记-清除-整理算法`。二者的本质区别是标记-清除算法是一种非移动式算法，标记压缩是一种移动式算法。
    - 使用标记压缩算法执行垃圾收集后，存活的对象会按照内存地址依次排列，未被标记的对象会被回收掉。当我们需要给一个新对象分配内存空间时，JVM只需要持有一个内存的起始地址即可，这相对于维护一个空闲列表来说少了许多的开销。

4. 指针碰撞：
    - 如果内存空间以规整有序的方式分布，即已用和未用的内存各自一边，彼此之间维系着一个记录下次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式称为指针碰撞。

5. 优点：
    - 优化了标记清除算法中会产生内存碎片的问题，再为对象分配内存空间时，JVM只需要持有一个起始内存地址即可。
    - 不存在复制算法需要占用额外的内存空间的问题。

6. 缺点：
    - 效率上低于复制算法。
    - 移动对象时如果对象被其他对象引用，还需要调整对象的引用地址。
    - 移动过程中需要停止用户程序。











