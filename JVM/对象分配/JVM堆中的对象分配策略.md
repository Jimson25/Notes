## 一、对象分配策略

1. 随着JIT编译器的发展与逃逸分析技术的成熟，栈上分配和标量替换优化技术将会对对象的分配策略产生一些影响，所有对象都是分配在堆上就不是那么的绝对了。在虚拟机中存在一种特殊情况，如果`经过逃逸分析`后发现`一个对象并没有逃逸出方法`的话，那么`该对象就会被优化为栈上分配`，此时就不需要对该对象执行垃圾回收，对象的生命周期和方法绑定，当方法出栈时对象就消失。

2. 逃逸分析是一种可以有效减少java程序中的同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，HotSpot编译器能分析出一个对象引用的适用范围从而决定时候要将这个对象分配到堆上。

3. 逃逸分析的基本行为是分析一个对象的动态作用域：
    - 当一个对象在方法中被定义后，对象只在方法内部使用，那么就认为这个对象没有发生逃逸。
    - 当一个对象在方法中被定义后，它被外部方法所引用则认为该对象发生了逃逸。如将对象作为返回值返回、作为参数传递到其他方法中等。

4. 使用逃逸分析后，编译器可以对java代码进行如下优化：
    - 栈上分配：在JIT编译期间，如果发现一个对象没有逃逸出方法，那么可能会将其优化为栈上分配，当方法执行结束后该栈帧被回收，对象也随之消亡。

    - 同步省略：如果发现一个对象只能在一个线程中被访问，那么对于这个对象可以不用考虑同步操作。在编译期间，如果编译器发现一个对象的某段同步代码块只能被一个线程所访问，那么编译器在编译期间会把这段代码块的锁优化掉。

    - 分离对象或标量替换：有的对象不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（全部）可以不存储在内存中，而是存储在cpu寄存器中。`标量是指的无法被分割的数据` ，如java中的基本数据类型。相对应的，那些`可以被分解的数据被称为聚合量`，如java中的对象。在编译期间，如果编译器发现一个对象不会被外界访问到（未发生逃逸），那么就会把这个对象拆分为若干个成员变量来替换，这个过程就成为标量替换。在下面的代码中，编译器会将`Circle`类中的`Point`对象替换为两个变量`x,y`，此时在程序执行过程中就不需要创建point对象了。
        ```java
        class Circle{
            public void doSomething(){
                Point point = new Point();
                point.getX();
                point.getY();
            }
        }
        class point{
            private int x;
            private int y;

            //getter/setter
        }
        ```

5. 在开发中，从节省内存和程序执行效率上考虑的话，能使用局部变量就不要在方法外定义成成员变量。

6. 逃逸分析小结：
    - 逃逸分析技术不成熟，其根本原因是无法保证逃逸分析带来的性能优化大于它的性能消耗，虽然执行逃逸分析会对程序执行带来优化，但是进行逃逸分析本身是需要消耗性能的。

7. 逃逸分析参数设置：
    - -XX:DoEscapeAnalysis  用于显式开启逃逸分析
    - -XX:PrintEscapeAnalysis   用于查看逃逸分析结果 
    - -XX:EliminateAllocations  开启标量替换，允许将对象打散分配到栈上。
