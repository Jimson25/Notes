# 知识点汇总

## 计算机基础

### 计算机网络

#### ISO参考模型

#### 五层参考模型

#### 网络模型各层协议

#### TCP/UDP区别

#### TCP连接过程

### 数据结构

#### 链表特点

#### 栈与队列

#### 二叉树

#### 红黑树

#### B树、B+树

#### 选择排序

#### 冒泡排序

#### 二分法查找

### 操作系统

#### 进程死锁

#### 银行家算法

## JAVA SE

### 初级

#### 集合

##### List、Set、Map之间的区别

* `List`: 存储的元素是有序的、可重复的。
* `Set`: 存储的元素不可重复的。
* `Map`: 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

##### ArrayList和LinkedList在性能上有什么区别？

- `ArrayList`: 基于数组实现，随机访问性能更好。可以基于 `对象内存地址+元素下标*元素类型占用的内存大小` 直接计算出元素的内存地址，因此查询速度快。但是对于新增和删除，由于在内存中是顺序表结构，因此需要调整后续所有元素的内存地址。
- `LinkedList`：基于双向链表实现，顺序访问性能更好。写入和删除上只需要修改要插入的位置的节点的内存地址变量（地址指针）即可完成插入和删除。而对于查找元素，链表需要从头到尾依次遍历链表中的节点，直到找到所需的元素为止。

##### 能不能在for循环遍历中删除list中的元素？

不能，遍历时删除元素会抛出 `java.lang.UnsupportedOperationException`异常。

##### 如何在遍历List时安全地删除元素？

- 可以使用迭代器中的remove()方法删除。

```java
Iterator<Integer> iterator = list.iterator();
while (iterator.hasNext()) {
    Integer value = iterator.next();
    if (value % 2 == 0) {
        iterator.remove();
    }
}

```

- 可以使用list提供的 `removeIf()` 实现删除，底层还是基于迭代器删除。

##### 如何在List中实现排序？怎么实现自定义排序规则？

- 可以使用 `Collections.sort(list)` 或 `list.sort()` 实现对list的排序。在1.8之后推荐使用后者。
- 要实现自定义排序规则，可以在调用 `sort()`方法时传入一个 `Comparator `类型的对象，重写其中的 `compare()`方法实现自定义排序规则。compare方法接受两个要比较的参数，并根据你的自定义规则返回一个整数值，该值可以是负数、零或正数，分别表示第一个参数小于、等于或大于第二个参数。
- 除了传入一个实现 `Comparator` 接口的对象之外，还可以通过方法引用传入一个用于比较的静态方法。这个方法所属的类可以不用实现 `Comparator` 接口，只需要保证方法签名和 `Comparator` 类中的 `compare()` 方法一致即可。

```java
Integer[] ints = {1, 2, 3, 4, 5, 6};
List<Integer> list = Arrays.asList(ints);

list.sort(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;
    }
});
System.out.println(list);
```

##### 解释ArrayList扩容机制

当ArrayList中的元素数量达到当前容量时，ArrayList会进行扩容。扩容的过程大致如下：

**扩容计算：** 首先，ArrayList会计算一个新的容量。新的容量通常是原容量的1.5倍（即原容量加上原容量的一半）。但是，如果计算出的新容量小于当前所需的容量（例如，你一次性添加了大量的元素），那么新容量会被调整为当前所需的容量。

**数组复制：** 然后，ArrayList会创建一个新的数组，其大小为新计算出的容量。接着，它会将旧数组中的所有元素复制到这个新数组中。

**引用更新：** 最后，ArrayList内部的对象引用会从旧的数组切换到新的数组，这样ArrayList就可以使用新的更大的数组来存储元素。

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### 什么是 Set 集合？它与 List 有什么区别？

Set 集合是一种不允许重复元素的集合，而 List 允许重复。Set 是无序的，而 List 是有序的。

##### HashSet 和 TreeSet 之间有什么区别？

HashSet 是基于哈希表实现的，无序且不允许重复元素；TreeSet 是基于红黑树实现的，有序且不允许重复元素。

##### HashSet 和 HashMap 之间有什么联系？

HashSet 底层使用了 HashMap 来存储元素，只是将元素的值作为 HashMap 的键，值都是同一个对象。

```java
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

##### 使用HashSet存储自定义对象时，可能会出现什么问题？应该怎么避免？

当使用HashSet存储自定义对象时，如果对象没有重写hashCode方法，那么计算出来的hashCode是基于对象的内存地址的哈希值。这意味着，即使两个对象的属性值相同，它们的hashCode也可能不同。

要想将自定义对象存入HashSet，需要正确的重写对象类的hashCode方法。

##### HashSet是否允许存入null值？

hashSet允许存入一个null值。

##### 什么是集合的无序性？

集合元素的无序性是指元素在集合中的顺序是不固定的，即元素的实际顺序不等同于元素插入集合中的顺序。

集合的有序性分为两种，一种是插入顺序有序，一种是元素顺序有序。前一种如ArrayList，LinkedList，这类集合对象会保存元素初始的插入顺序作为集合中元素的顺序。后一种如TreeSet，它的底层采用的是红黑树实现，在元素写入集合时会根据元素的值进行排序。

对于TreeSet类型，如果元素是一个自定义的对象，那么它的写入顺序分两种情况讨论。第一种情况是该对象实现了 `Comparable` 接口，此时TreeSet会使用接口的 `compareTo` 方法比较元素的值，并根据结果进行排序。第二种情况是该对象没有实现 `Comparable` 接口，这时候在创建TreeSet时需要手动提供一个自定义的比较器来实现元素排序，否则会抛出 `ClassCastException`。

```java
TreeSet<Person> treeSet = new TreeSet<>((o1, o2) -> {
    int age = o1.getAge() - o2.getAge();
    if (age < 0) {
        return -1;
    } else if (age == 0) {
        return 0;
    }
    return 1;
});
treeSet.add(new Person("zhangsan", 11));
treeSet.add(new Person("lisi", 12));
treeSet.forEach(e -> System.out.print(e + "   "));
```

#### 泛型

##### 什么是泛型？为什么要使用泛型？

泛型是一种参数化类型的机制，允许我们编写通用的代码，可以在运行时指定具体的类型。使用泛型可以提高代码的可读性、安全性和重用性。

##### 什么是泛型类和泛型方法？

* **泛型类** ：一个类可以使用泛型来定义其属性、方法或构造函数的参数类型。例如，`ArrayList<T>` 是一个泛型类，其中的 `T` 表示元素的类型。
* **泛型方法** ：一个方法可以使用泛型来定义其参数类型或返回值类型。例如，`public <T> T getFirst(List<T> list)` 是一个泛型方法，它返回列表中的第一个元素

##### 什么是类型擦除？

类型擦除是指在编译时擦除泛型类型信息，将泛型类型转换为原始类型。

1. **类型擦除** ：

* Java的泛型在编译期间会将所有的泛型信息擦除，替换为实际的类型。
* 在生成的字节码中，不包含泛型中的类型信息。
* 使用泛型时，编译器会在编译时去掉类型参数，这个过程称为类型擦除。
* 例如，定义 `List<Object>`和 `List<String>`等类型，在编译后都会变成 `List`，JVM看到的只是 `List`，而泛型附加的类型信息对JVM是不可见的。

1. **类型擦除后保留的原始类型** ：

* 原始类型是擦除泛型信息后，类型变量的真正类型。
* 无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用 `Object`）替换。
* 例如，`Pair<T>`中，如果 `T`是无限定的类型变量，那么用 `Object`替换，结果就是一个普通的类，类似于泛型加入Java语言之前的已经实现的样子。

1. **示例** ：

* 假设我们有一个泛型类 `Pair<T>`，如果 `T`是无限定的类型变量，那么原始类型就是 `Object`。
* 如果类型变量有限定，原始类型就用第一个边界的类型变量类替换。

**深入一些去了解：**

我们已经知道，在编译期间，编译器会执行类型擦除，`ArrayList<Integer>`变为了原始类型 `ArrayList`，并且它的元素类型被视为 `Object` 。但是这里需要注意一点，这里擦除的只是编码时传入的静态的元素类型，如这里的Integer，在实际运行过程中，传入的元素的实际类型是会被保留的。比如这里，在内存中呈现的依然是元素真实的类型Integer。

可以简单点理解，将泛型理解为一种开发期间编译器对开发人员的一种约束，它为开发人员在开发期间提供一种强类型检查机制，开发人员可以在编译期间检查到类型错误，而不必等待运行时才发现。

如下面的代码，结果返回为 `true` ，因为在实际内存中，元素的类型还是Integer。

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(1);
System.out.println(list.get(0) instanceof Integer);
```

##### 什么是伪泛型？为什么java中的泛型是伪泛型？

伪泛型是指 Java 中的泛型机制在编译期间会将所有的泛型信息擦除，替换为实际的类型。尽管我们在源代码中使用了泛型，但在生成的字节码中，不包含泛型类型信息。因此，我们称之为“伪泛型”。

具体来说，以下是关于伪泛型的一些要点：

* **类型擦除** ：在编译期间，Java 编译器会将泛型信息擦除，将泛型类型转换为原始类型。这意味着在运行时，我们无法直接查看泛型的具体类型。
* **原始类型** ：原始类型是擦除泛型信息后，类型变量的真正类型。无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用 `Object`）替换。

虽然泛型在源代码中提供了类型安全性和抽象性，但在运行时，泛型的类型信息被擦除，只保留了原始类型。因此，我们称之为“伪泛型”。

Java 中的泛型是伪泛型，因为在运行时并没有实际的泛型类型信息，只有在编译时才会进行类型检查。

##### 什么是泛型的上下界通配符？起到什么作用？

* **上界通配符** （`<? extends T>`）：表示泛型参数必须是 `T` 或其子类。
* **下界通配符** （`<? super T>`）：表示泛型参数必须是 `T` 或其父类。

#### IO流

##### 字节流和字符流的区别是什么？

- **字节流**（InputStream/OutputStream）是用于处理原始二进制数据的流
- **字符流**（Reader/Writer）是用于处理字符数据的流。字符流在内部使用字节流来操作文件，但它还会使用合适的字符集来解码字节。

##### 在读取一个文件内容写入到另一个文件时怎么避免出现乱码？

在读取和写入文件时，乱码通常是由于字符编码不一致导致的。为了避免乱码，你需要确保在读取和写入文件时使用的字符编码是一致的。在Java中，可以使用 `InputStreamReader`和 `OutputStreamWriter`来指定字符编码。

```java
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt"), "UTF-8"));
     BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("output.txt"), "UTF-8"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
} catch (IOException e) {
    e.printStackTrace();
}

```

除此之外，如果文件的编码格式未知或者为了最大程度地保持文件的原始字节序列，可以使用字节流来实现文件内容的复制，从而避免编码转换可能带来的问题。
在Java中，InputStream和OutputStream及其子类是用于处理字节数据的流。使用字节流可以保证读取和写入到文件系统中的数据是完全相同的字节序列，不会进行任何字符集的转换。这样可以确保文件在复制过程中保持其原始的字节内容，从而避免出现乱码问题。

##### 缓冲流是怎么提高IO操作性能的？

缓冲流（BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter）在内部维护一个缓冲区，当我们从流中读取或写入数据时，它会尽可能地一次读取或写入多个字节到缓冲区，这样可以减少实际的物理读写操作次数，从而提高IO操作的性能。

##### 什么是序列化和反序列化？有哪些第三方的序列化库？

- **序列化**是将对象的状态信息转换为可以存储或传输的形式的过程。
- **反序列化**则是将已序列化的数据恢复为对象的过程。

Java提供了 `java.io.Serializable`接口来支持序列化。同时，Java中也有许多第三方的序列化库，例如：

* **Google Gson** ：一个可以将Java对象转换为其JSON表示形式的库，也可以将JSON字符串转换回Java对象。
* **Jackson** ：一个可以读取和写入JSON和其他数据格式（如XML和CSV）的库。
* **Fastjson2** ：阿里巴巴的开源JSON处理库，可以将Java对象转换为JSON格式，也可以将JSON字符串转换为Java对象。

##### 什么是java中的文件锁？

文件锁是用于控制对文件的并发访问。

Java的 `java.nio.channels.FileLock`类提供了对文件的锁定和解锁操作。文件锁可以是共享的，也可以是独占的。共享锁只允许其他并发进程读取文件，但不允许写入。独占锁则不允许其他并发进程读取或写入文件。

```java
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;

public class FileLockExample {
    public static void main(String[] args) {
        Thread t1 = new Thread(new Worker(), "Thread-1");
        Thread t2 = new Thread(new Worker(), "Thread-2");
        t1.start();
        t2.start();
    }

    static class Worker implements Runnable {
        @Override
        public void run() {
            try {
                RandomAccessFile file = new RandomAccessFile("test.txt", "rw");
                FileChannel fileChannel = file.getChannel();

                System.out.println(Thread.currentThread().getName() + " is waiting to acquire the lock...");
                FileLock lock = fileChannel.lock();
                System.out.println(Thread.currentThread().getName() + " has acquired the lock.");

                Thread.sleep(3000);

                lock.release();
                System.out.println(Thread.currentThread().getName() + " has released the lock.");

                fileChannel.close();
                file.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

### 中级

#### JUC

##### CountDownLatch类的作用是什么？

`CountDownLatch`是一个同步工具类，它允许一个或多个线程等待直到在其他线程中执行的一组操作完成。

假设我们有一个应用程序，在启动之前需要初始化多个服务。我们想要在所有服务都初始化完成后才启动应用程序的主线程。我们可以使用 CountDownLatch 来实现这一点。

```java
import java.util.concurrent.CountDownLatch;

public class ApplicationLauncher {

    // 假设有三个服务需要初始化
    private static final int N = 3;

    public static void main(String[] args) {
        // 创建一个计数器，初始化为3
        CountDownLatch latch = new CountDownLatch(N);

        // 创建并启动三个服务初始化线程
        for (int i = 0; i < N; ++i) {
            new Thread(new ServiceInitializer(latch, "Service" + (i+1))).start();
        }

        // 主线程等待所有服务初始化完成
        try {
            latch.await(); // 阻塞，直到计数器降为0
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 所有服务都已初始化，主线程可以继续执行
        System.out.println("所有服务已初始化，应用程序正在启动...");
    }

    // 服务初始化任务
    static class ServiceInitializer implements Runnable {
        private final CountDownLatch latch;
        private final String serviceName;

        public ServiceInitializer(CountDownLatch latch, String serviceName) {
            this.latch = latch;
            this.serviceName = serviceName;
        }

        @Override
        public void run() {
            try {
                // 模拟服务初始化的耗时操作
                Thread.sleep((long) (Math.random() * 10000));
                System.out.println(serviceName + " 初始化完成。");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // 完成初始化后，计数器减1
                latch.countDown();
            }
        }
    }
}

```

#### AQS

### 高级

#### JVM

#### 并发锁

##### 什么是分段锁？分段锁和同步锁有什么区别？

#### String

### Netty框架

### 通讯协议

#### http协议

#### socket协议

## JAVA Web

### jsp & servlet

### JavaScript

## 架构设计

### 设计模式

#### 六大原则

#### 责任链模式

#### 单例模式

##### 双重检查锁实现

- 代码实现：

```java
public class Singleton {
    private volatile static Singleton uniqueSingleton;

    private Singleton() {
    }

    public Singleton getInstance() {
        if (null == uniqueSingleton) {
            synchronized (Singleton.class) {
                if (null == uniqueSingleton) {
                    uniqueSingleton = new Singleton();
                }
            }
        }
        return uniqueSingleton;
    }
}
```

- 说明：
  - volatile关键字是为了防止指令重排序。在虚拟机中，为一个对象分配内存空间可以分为3个步骤：分配内存空间、初始化对象、将对象指向分配的内存空间。但是在一些编译器中，为了优化性能，会对第二步和第三步进行重排序。此时可能出现引用指向一块内存区域之后，对象没有初始化成功。使用volatile关键字之后可以禁止指令重排序。
  - 双重检查锁的第一个if判断是为了提高代码性能，避免每次获取对象时都对请求加锁。
  - 第二个if判断是为了避免出现重复的对象实例。在多线程环境下，假设第一个线程执行完第一个if判断之后，在等待获取同步锁之前时间片结束，该线程并未获取到同步锁，此时第二个线程获取单例对象并成功创建对象实例。这里如果在同步代码内添加第二个if判断，那么等第一个线程获取到时间片之后，会成功获取同步锁并创建一个新的对象。而如果在同步锁代码块内添加第二个判断，那么第一个线程在进入代码块之后会再执行一次判断，避免重复创建对象。
- 缺陷：
  - 以上代码中，可以通过反序列化或者对象的克隆实现获取多个对象。
  - 以上代码中，可以通过反射的方式获取多个对象。

##### 枚举类实现

- 代码实现

```java
public enum Singleton {
    INSTANCE;

    public String doXX() {
        return "success";
    }

    public static void main(String[] args) {
        System.out.println(Singleton.INSTANCE.doXX());
    }
}
```

- 说明

在java中，枚举类的实例由JVM保证线程安全。


#### 工厂模式

#### 模板方法

### 设计方法

#### 线程池

#### 分布式锁

#### 分布式事务

#### 缓存一致性

#### 接口幂等性

## 数据库

### SQL

#### 三范式

### MySQL

### Oracle

## Linux

### docker & k8s

## Maven

### Maven依赖安装

maven安装jar包到本地maven仓库

```
mvn install:install-file 
-Dfile=d:/xxx-spring-boot-starter-2.x-9.5.1.jar 
-DgroupId=com.xxx.appserver 
-DartifactId=xxxxx-spring-boot-starter-9.5.1
-Dversion=9.5.1 
-Dpackaging=jar
```

## Redis

## Spring

## 微服务

## 实际问题

### 分布式集群下保证只有一个节点初始数据

### 上线后接口耗时偶发增大

### web中间件最大请求参数设置导致请求数据丢失问题

### nginx限制文件上传大小问题
