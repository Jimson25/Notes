# ThreadPoolExecutor线程池

## 构造方法

对于ThreadPoolExecutor线程池，推荐直接使用new来创建对象，根据业务需要自行设置其中的参数。

```java
public ThreadPoolExecutor(int corePoolSize, 
				int maximumPoolSize,
				long keepAliveTime,
				TimeUnit unit,
				BlockingQueue<Runnable> workQueue,
				ThreadFactory threadFactory,
				RejectedExecutionHandler handler)
```

- **corePoolSize：** 核心线程数，指定线程池中能够同时运行的核心线程数。当提交任务时，如果线程池中的线程数少于核心线程数，无论是否有空闲的线程可用，都会创建一个新的核心线程来执行任务。核心线程默认不会被回收，除非显式指定 `executor.allowCoreThreadTimeOut(true)`
- **maximumPoolSize：** 线程池中的最大线程数（核心线程数+非核心线程数）。其中，核心线程数不会被回收，非核心线程数在等待时间超过 `keepAliveTime`之后会被回收。
- **keepAliveTime：** 线程存活时间。设置线程池中非核心线程的空闲时间，线程空闲时间超过该值之后会被回收。
- **unit：** 线程存活时间的单位，通过 `TimesUnit `设置。
- **workQueue：** 任务等待队列。线程池有新的任务进来时，首先分配核心线程处理该任务，如果没有空闲的核心线程，则将任务添加到等待队列中等待执行。当大量任务放入任务等待队列导致队列满之后，再有新的任务到来时，如果池中的线程数小于最大线程数，则会创建一个新的线程来执行等待队列中的第一个任务（FIFO）。如果新任务到来时池中的线程数等于最大线程数，并且工作队列已满，则会执行拒绝策略。
- **threadFactory：** 用于创建线程的工厂，可以设置线程名称、优先级等参数。
- **handler：** 当线程池已满，且工作队列也已满时，新提交的任务无法被处理时，采取的拒绝策略。常见的策略有 `AbortPolicy`（默认，抛出异常）、`CallerRunsPolicy`（在提交线程中执行任务）、`DiscardOldestPolicy`（丢弃队列中最旧的任务）和 `DiscardPolicy`（丢弃新提交的任务）。


## 任务调度策略

1. 如果线程池中的线程数小于核心线程数，会创建一个新的核心线程来执行任务。
2. 如果线程池中的线程数达到了核心线程数，任务会被放入工作队列排队等待执行。
3. 如果工作队列已满，而线程池中的线程数小于最大线程数，会创建一个新的非核心线程来执行任务。
4. 如果线程池中的线程数已达到最大线程数，并且工作队列也已满，会根据指定的饱和策略来处理任务。

所以，如果线程池中的线程数小于核心线程数，会优先创建核心线程来执行任务，不会考虑空闲线程。只有当线程池中的线程数达到核心线程数时，才会考虑工作队列和非核心线程。

总结起来，核心线程会一直保持存活，而非核心线程则根据任务的数量和线程池的配置动态创建和销毁。


## 方法调用

### execute()和submit()方法的区别

在 `ThreadPoolExecutor`线程池中 `execute()`和 `submit()`方法提交线程，一下是两个方法的一些区别：

- 返回值：`execute()` 方法没有返回值，它只是简单地提交任务并执行。而 `submit()` 方法返回一个 `Future` 对象，可以用于获取任务的执行结果。
- 异常处理：`execute()` 方法在执行任务时如果抛出了异常，会将异常直接抛出，不会进行处理。而 `submit()` 方法会将异常封装在 `Future` 的 `get()` 方法中，如果调用 `get()` 方法获取结果时发生了异常，会抛出 `ExecutionException`。
- 任务类型：`execute()` 方法只能提交实现了 `Runnable` 接口的任务。而 `submit()` 方法可以提交实现了 `Runnable` 接口的任务，也可以提交实现了 `Callable` 接口的任务。如果提交的是 `Callable` 任务，可以通过 `Future` 对象的 `get()` 方法获取返回值。

主线程如果调用execute()方法，则主线程不会接收线程返回值继续往下执行。如果主线程调用线程池的submit()方法，则会接收一个Future对象，此时主线程依然正常执行，但是如果调用返回对象的 `get()`方法，则主线程会阻塞在此处等待子线程执行结束后返回执行结果。这里可以设置get()方法的等待时间，即线程的超时时间，当阻塞时间超过设置的超时时间后，主线程不会等待子线程执行结果而继续执行后续逻辑并抛出 `TimeoutException`异常。
