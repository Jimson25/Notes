# 一、MySQL逻辑架构

## 1.2 并发控制

### 1.2.1 读写锁

- 读锁：读锁是共享的，或者说是互相不阻塞的。多个客户可以在同一时刻读取同一个资源而互不干扰。
- 写锁：写锁是排他的，即一个写锁会阻塞其他的写锁或读锁。这种安全策略是为了保证在给定时间内只有一个用户能访问数据资源，即只有一个用户能执行写入，并防止其他用户读取正在写入的内容。

### 1.2.2 锁粒度

​	对于提高资源共享的方式中，最理想的方式是只锁住我们正在修改的数据片，即锁的粒度越小越好。但是随之而来的问题是对于锁的各种操作如获取锁、检查锁是否释放以及释放锁等，这些操作都会增大系统开销。如果系统花费大量的时间去管理锁而不是存取数据，那么系统的性能也会因此而受到影响。

- 锁策略：锁策略根本上来讲就是在锁粒度和数据安全上找到平衡。
- 表锁：表锁是一种开销最小的策略，它会锁定整张表（同时会导致并发性能降低）。一个用户在对表进行写操作前，需要先获取写锁，这会阻塞其他用户对该表的读写操作。只有没有写锁时其他用户才能获取读锁，读锁之间是互相不阻塞的。写锁具有比读锁更高的优先级，在某些情况下，写锁会被插入到读锁前面，即在等待队列中会先执行写锁在执行读锁。***读锁不能插入到写锁之前***。
- 行级锁：行级锁会带来巨大的性能开销，但是它支持更大的并发。

## 1.3 事务

​	事务是一组原子性的sql查询，或者说是一个独立的工作单元。事务内的语句，要么全部执行，要么全部不执行。

- 原子性：事务必须被视为一个不可分割的最小工作单元，事务中的SQL查询要么全部提交成功，要么全部失败回滚。
- 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。***如A账户给B账户转账1000元，此时A \- 1000元，B + 1000元，在执行前后数据库中金额总量一致***
- 隔离性：一个事务在执行提交之前其内部所做的修改在其他事务中是不可见的。如上面案例中，在执行完A-1000之后，此时在另一个事务中看到的A是-1000之前的状态，只有在提交之后其他事务获取到的数据才是-1000之后的状态。（根据具体隔离级别确定）
- 持久性：事务一旦提交，其所做的修改会永久的保存在数据库中。

### 1.3.1 隔离级别

- 未提交读(READ UNCOMMITED)：在这一隔离级别中，事务所做的修改，即使没有提交，对其他事务也是可见的。即事务可以读取到未提交的数据，这也被称为**脏读**。这种隔离级别一般不在实际项目中使用。
- 提交读(READ COMMIT): 在这一隔离级别中，一个事务开始时，只能看见已经提交的事务的修改。这一隔离级别也被称为**不可重复读** ，因为在两次查询中，可能会得到不一样的结果。
- 可重复读(repeatable read)：该级别解决了脏读的问题，它可以保证在一个事务中多次读取同样的记录的结果是一致的。这一隔离级别理论上无法解决**幻读（当一个事务读取某个范围内的记录时，另一个事务又往该范围内插入了新的数据，当之前的事务再次读取该范围的数据时，会产生幻行）**的问题。**该级别是MySQL的默认事务隔离级别**
- 可串行化(SERIALIZABLE)：该级别是最高的隔离级别。它通过强制事务串行执行，避免了前面的幻读的问题。

### 1.3.2 死锁

​	死锁是指两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

InnoDB中处理死锁的办法是，将持有最少行级排他锁的事务进行回滚（要执行最少的写操作的事务）。

### 1.3.3 事务日志

​	使用事务日志之后，存储引擎在修改数据时只需要修改其在内存中的数据即可，再将该修改行为记录在硬盘日志中。在事务日志持久后，内存中被修改的数据可以再慢慢被刷回磁盘中。目前大多数存储引擎都是这样实现的，这种行为成为预写式日志，修改数据需要写两次磁盘（写日志+持久话内存数据）。

### 1.3.4 MySQL中的事务

​	MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。除此之外还有一些第三方存储引擎。

#### 自动提交

​	MySQL默认使用自动提交模式。如果不是显示的使用`start transaction`开启一个事务，那么每一个查询都会被当作一个事务执行提交操作。

​	MySQL可以使用`set autocommit = 0|1`来启用(1)或禁用(0)自动提交模式。当设置为禁用时，必须手动使用`commit`或`rollback`来执行提交或回滚

#### 混用存储引擎

​	如果在一个事务中同时执行了对以InnoDB和MyISAM作为存储引擎的表的更新操作，在提交的时候不会有问题，但是如果此时执行回滚操作，那么会出现使用MyISAM存储引擎的表的数据无法回滚。所以在设计表的时候需要为其选择合适的存储引擎。

#### 显式和隐式锁定

​	在InnoDB中，事务执行过程中，会隐式的对数据加上行级锁，在事务提交时同时释放所有锁。同时我们也可以在语句后面使用`for update`显式为数据加锁。

## 1.4 多版本并发控制

​	多版本并发控制(MVCC)可以看作是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因此开销更低。

​	InnoDB是通过为每一行后面添加两个隐藏列来实现MVCC的。这两个列一个保存的是创建时间，一个保存的是过期时间（删除时间），但是保存的不是实际的时间而是系统版本号。该版本号会根据事务的开始而增加。

#### select：

​	InnoDB会根据以下条件查询数据

- 查找创建时间版本号小于或等于当前事务的行。
- 查找删除时间版本号未定义或大于当前版本号。

#### insert：

​	InnoDB会为新插入的数据保存当前事务的版本号作为版本号

#### delete

​	InnoDB会为删除的记录保存其删除版本号为当前事务版本号

#### update

​	InnoDB会插入一行新数据，将当前事务版本号作为创建时间版本号，并将当前事务版本号作为原数据的删除版本号

## 1.5 存储引擎

### 1.5.1 InnoDB

### 1.5.2 MyISAM

#### 特性

- 加锁：存储引擎会对整张表加锁而不是针对行。读取时会对整张表加共享锁，写入数据时加排他锁。但是读取时可以插入数据。
- 修复：`CHECK TABLE mytable`检查表错误，如果有错误可以通过`REPAIR TABLE mytable`修复。mysql服务器关闭时，可以通过`myisamchk`工具进行检查和修复。
- 索引特性
- 延迟更新索引键

#### 压缩表

- 对于只读的表，可以使用`myisampack`进行压缩（打包pack）。压缩表可以极大的减少磁盘占用，减少磁盘I/O。

### 1.5.3 其他存储引擎

#### Archive引擎

​	Archive引擎只支持SELECT和INSERT操作，数据占用空间很少。Archive引擎支持行级锁和专用的缓冲区，可以实现并发插入，但是每次执行select时都需要执行全表扫描。

### 1.5.5 存储引擎选择

​	除非有明确的需求需要用到InnoDB所不具备的属性，并且没有其他的办法替代，否则都应该选择InnoDB存储引擎。

<<<<<<< HEAD
# 二、MySQL基准测试



# 三、服务器性能剖析

## 3.1 性能优化简介

> 性能：简单定义为完成某个任务所需的时间的度量。数据库服务器的性能用查询的响应时间来度量，单位是每个查询所花费的时间。

> 在进行性能优化之前需要先判断为什么服务器执行查询需要消耗这么长的时间，然后减去或者去除掉其中一些不必要的时间消耗。即在进行优化之前需要先测量执行时间消耗在哪些地方了。

一项任务的执行时间可以被分为 **执行时间** 和 **等待时间** 两部分。

- 执行时间上主要是测量定位不同子任务的执行时间，然后优化其中执行时间较长的子任务。
- 等待时间上主要是存在于磁盘或CPU等硬件资源的争抢上。

### 3.1.1 通过性能剖析分析

性能剖析是测量和分析时间花费在那里的主要方法。一般分为两个步骤：

- 测量任务所花费的时间
- 对结果进行统计和排序，将重要的任务排在前面。


=======
### 1.5.6 转换表的引擎

#### 	ALERT TABLE

```mysq
ALERT TABLE TABLE EMGIN = InnoDB;
```

- 适合所有存储引擎

- 需要执行很长时间。这种方式下，MySQL会新建一张新存储的表，并将数据按行复制到新表中。复制期间会消耗系统所有IO性能，同时原表会加上读锁。

  #### 导出并修改

  使用mysqldmp将数据导出为dmp文件，修改dmp文件中create table语句中的存储引擎选项并修改表名。

- 安全

- 效率低

  #### 创建与查询

  创建一个新的存储引擎的表，再使用insert ··· select语法导出语句。

  ```mysql
  create table innoDB_table like myisam_table;
  alert table innodb_table engine = InnoDB;
  insert into innodb_table select * from myisam_table;		
  ```

- 安全高效

- 在执行的时候最好将原表加锁，保证两张表数据一致。

- 如果数据量大，最好分批量加事务执行。



# 二、Mysql基准测试

> 基准测试是针对系统设计的一种压力测试。通常目标是为了掌握系统的行为。



## 2.2 基准测试的策略

​	基准测试有两种主要策略：	一是针对整个系统的整体测试，另外是单独测试Mysql。前一种策略也被称为集成式（full-stack)，后一种被称为单组件式。

### 2.2.1 基准测试指标

#### 吞吐量

​	吞吐量是指单位时间内的事务处理数。这类基准测试主要是针对在线事务处理的吞吐量，非常适合多用户的交互式应用。常用的单位是每秒事务数（TPS）或每分钟事务数（TPM）。

#### 响应时间或延迟

​	这一指标用于测试任务所需的整体时间。根据不同的时间单位可以计算出平均响应时间、最小响应时间、最大响应时间和所占百分比。在测试中一般使用最大响应时间百分比替代最大响应时间。如95%的请求响应时间都是5ms。

#### 并发性

​	web站点的并发性不等同于数据库的并发性。一般情况下，web站点的高并发会导致数据库的高并发，但是在两者中间的服务端开发语言和工具集都会对其产生影响。web站点的并发性不是指在同一时间有多少用户在浏览站点，而是在同一时间有多少并发请求传送到服务器。

​	在一个应用系统中，可以同时打开很多个MySQL数据库服务器连接，但是只有少数几个连接能并发请求到数据库服务器。MySQL并发性基准测试需要关注的是正在工作中的并发请求而不是连接到数据库的连接。需要测试的是当并发性增加时，吞吐量是否下降，响应时间是否延长。

#### 可扩展性

​	可扩展性简单的说就是在给系统增加一倍的工作，在理想情况下能获得两倍的结果。或者给系统增加一倍的资源能获取两倍的吞吐量。



060121201660
>>>>>>> 3360b10e278e1c2bf6a99f149de5e3d105e6b3ea
