# 一、MySQL逻辑架构

## 1.2 并发控制

### 1.2.1 读写锁

- 读锁：读锁是共享的，或者说是互相不阻塞的。多个客户可以在同一时刻读取同一个资源而互不干扰。
- 写锁：写锁是排他的，即一个写锁会阻塞其他的写锁或读锁。这种安全策略是为了保证在给定时间内只有一个用户能访问数据资源，即只有一个用户能执行写入，并防止其他用户读取正在写入的内容。

### 1.2.2 锁粒度

​	对于提高资源共享的方式中，最理想的方式是只锁住我们正在修改的数据片，即锁的粒度越小越好。但是随之而来的问题是对于锁的各种操作如获取锁、检查锁是否释放以及释放锁等，这些操作都会增大系统开销。如果系统花费大量的时间去管理锁而不是存取数据，那么系统的性能也会因此而受到影响。

- 锁策略：锁策略根本上来讲就是在锁粒度和数据安全上找到平衡。
- 表锁：表锁是一种开销最小的策略，它会锁定整张表（同时会导致并发性能降低）。一个用户在对表进行写操作前，需要先获取写锁，这会阻塞其他用户对该表的读写操作。只有没有写锁时其他用户才能获取读锁，读锁之间是互相不阻塞的。写锁具有比读锁更高的优先级，在某些情况下，写锁会被插入到读锁前面，即在等待队列中会先执行写锁在执行读锁。***读锁不能插入到写锁之前***。
- 行级锁：行级锁会带来巨大的性能开销，但是它支持更大的并发。

## 1.3 事务

​	事务是一组原子性的sql查询，或者说是一个独立的工作单元。事务内的语句，要么全部执行，要么全部不执行。

- 原子性：事务必须被视为一个不可分割的最小工作单元，事务中的SQL查询要么全部提交成功，要么全部失败回滚。
- 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。***如A账户给B账户转账1000元，此时A \- 1000元，B + 1000元，在执行前后数据库中金额总量一致***
- 隔离性：一个事务在执行提交之前其内部所做的修改在其他事务中是不可见的。如上面案例中，在执行完A-1000之后，此时在另一个事务中看到的A是-1000之前的状态，只有在提交之后其他事务获取到的数据才是-1000之后的状态。（根据具体隔离级别确定）
- 持久性：事务一旦提交，其所做的修改会永久的保存在数据库中。

### 1.3.1 隔离级别

- 未提交读(READ UNCOMMITED)：在这一隔离级别中，事务所做的修改，即使没有提交，对其他事务也是可见的。即事务可以读取到未提交的数据，这也被称为**脏读**。这种隔离级别一般不在实际项目中使用。
- 提交读(READ COMMIT): 在这一隔离级别中，一个事务开始时，只能看见已经提交的事务的修改。这一隔离级别也被称为**不可重复读** ，因为在两次查询中，可能会得到不一样的结果。
- 可重复读(repeatable read)：该级别解决了脏读的问题，它可以保证在一个事务中多次读取同样的记录的结果是一致的。这一隔离级别理论上无法解决**幻读（当一个事务读取某个范围内的记录时，另一个事务又往该范围内插入了新的数据，当之前的事务再次读取该范围的数据时，会产生幻行）**的问题。**该级别是MySQL的默认事务隔离级别**
- 可串行化(SERIALIZABLE)：该级别是最高的隔离级别。它通过强制事务串行执行，避免了前面的幻读的问题。

### 1.3.2 死锁

​	死锁是指两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

InnoDB中处理死锁的办法是，将持有最少行级排他锁的事务进行回滚（要执行最少的写操作的事务）。

### 1.3.3 事务日志

​	使用事务日志之后，存储引擎在修改数据时只需要修改其在内存中的数据即可，再将该修改行为记录在硬盘日志中。在事务日志持久后，内存中被修改的数据可以再慢慢被刷回磁盘中。目前大多数存储引擎都是这样实现的，这种行为成为预写式日志，修改数据需要写两次磁盘（写日志+持久话内存数据）。

### 1.3.4 MySQL中的事务

​	MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。除此之外还有一些第三方存储引擎。

#### 自动提交

​	MySQL默认使用自动提交模式。如果不是显示的使用`start transaction`开启一个事务，那么每一个查询都会被当作一个事务执行提交操作。

​	MySQL可以使用`set autocommit = 0|1`来启用(1)或禁用(0)自动提交模式。当设置为禁用时，必须手动使用`commit`或`rollback`来执行提交或回滚

#### 混用存储引擎

​	如果在一个事务中同时执行了对以InnoDB和MyISAM作为存储引擎的表的更新操作，在提交的时候不会有问题，但是如果此时执行回滚操作，那么会出现使用MyISAM存储引擎的表的数据无法回滚。所以在设计表的时候需要为其选择合适的存储引擎。

#### 显式和隐式锁定

​	在InnoDB中，事务执行过程中，会隐式的对数据加上行级锁，在事务提交时同时释放所有锁。同时我们也可以在语句后面使用`for update`显式为数据加锁。

### 1.4 多版本并发控制

​	多版本并发控制(MVCC)可以看作是行级锁的一个变种，但是它在很多情况下避免了加锁的操作，因此开销更低。

​	InnoDB是通过为每一行后面添加两个隐藏列来实现MVCC的。这两个列一个保存的是创建时间，一个保存的是过期时间（删除时间），但是保存的不是实际的时间而是系统版本号。该版本号会根据事务的开始而增加。

#### select：

​	InnoDB会根据以下条件查询数据

- 查找创建时间版本号小于或等于当前事务的行。
- 查找删除时间版本号未定义或大于当前版本号。

#### insert：

​	InnoDB会为新插入的数据保存当前事务的版本号作为版本号

#### delete

​	InnoDB会为删除的记录保存其删除版本号为当前事务版本号

#### update

​	InnoDB会插入一行新数据，将当前事务版本号作为创建时间版本号，并将当前事务版本号作为原数据的删除版本号



